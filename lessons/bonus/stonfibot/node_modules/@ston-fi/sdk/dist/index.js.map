{"version":3,"file":"index.js","sources":["../src/contracts/dex/constants.ts","../src/utils/parseAddress.ts","../src/contracts/dex/lp-account/LpAccountRevisionV1.ts","../src/contracts/dex/lp-account/LpAccount.ts","../src/contracts/dex/pool/PoolRevisionV1.ts","../src/contracts/dex/pool/Pool.ts","../src/utils/createJettonTransferMessage.ts","../src/utils/parseBoolean.ts","../src/contracts/dex/router/RouterRevisionV1.ts","../src/contracts/dex/router/Router.ts","../src/contracts/farm/constants.ts","../src/utils/parseString.ts","../src/contracts/farm/minter/FarmNftMinterRevisionV2.ts","../src/contracts/farm/minter/FarmNftMinter.ts","../src/utils/createSbtDestroyMessage.ts","../src/contracts/farm/nft/FarmNftItemRevisionV2.ts","../src/contracts/farm/nft/FarmNftItem.ts","../src/utils/index.ts"],"sourcesContent":["export const DEX_OP_CODES = {\n  ADD_LIQUIDITY: 0x7362d09c,\n  SWAP: 0x25938561,\n  PROVIDE_LIQUIDITY: 0xfcf9e58f,\n  DIRECT_ADD_LIQUIDITY: 0x4cf82803,\n  REFUND: 0x0bf3f447,\n  RESET_GAS: 0x42a0fb43,\n  COLLECT_FEES: 0x1fcb7d3d,\n  REQUEST_BURN: 0x595f07bc,\n} as const;\n\nexport const ROUTER_REVISION = {\n  V1: 'V1',\n} as const;\n\nexport const ROUTER_REVISION_ADDRESS: Record<\n  keyof typeof ROUTER_REVISION,\n  string\n> = {\n  [ROUTER_REVISION.V1]: 'EQB3ncyBUTjZUA5EnFKR5_EnOMI9V1tTEAAPaiU71gc4TiUt',\n} as const;\n","import TonWeb from 'tonweb';\n\nimport type { Address, Cell } from '@/types';\n\nconst { Address } = TonWeb;\n\nconst readIntFromBitString = (\n  bs: Cell['bits'],\n  cursor: number,\n  bits: number,\n) => {\n  let n = BigInt(0);\n\n  for (let i = 0; i < bits; i++) {\n    n *= BigInt(2);\n    n += BigInt(bs.get(cursor + i));\n  }\n\n  return n;\n};\n\nexport const parseAddress = (cell: Cell): Address | null => {\n  try {\n    let n = readIntFromBitString(cell.bits, 3, 8);\n\n    if (n > BigInt(127)) {\n      n = n - BigInt(256);\n    }\n\n    const hashPart = readIntFromBitString(cell.bits, 3 + 8, 256);\n\n    if (n.toString(10) + ':' + hashPart.toString(16) === '0:0') {\n      return null;\n    }\n\n    const s = n.toString(10) + ':' + hashPart.toString(16).padStart(64, '0');\n\n    return new Address(s);\n  } catch {\n    return null;\n  }\n};\n","import TonWeb from 'tonweb';\n\nimport { parseAddress } from '@/utils/parseAddress';\nimport { DEX_OP_CODES } from '../constants';\nimport type { Cell, BN } from '@/types';\n\nimport type { LpAccountRevision } from './LpAccountRevision';\n\nconst {\n  boc: { Cell },\n  utils: { BN },\n} = TonWeb;\n\nexport class LpAccountRevisionV1 implements LpAccountRevision {\n  public get gasConstants(): LpAccountRevision['gasConstants'] {\n    return {\n      refund: new BN(500000000),\n      directAddLp: new BN(300000000),\n      resetGas: new BN(300000000),\n    };\n  }\n\n  public createRefundBody: LpAccountRevision['createRefundBody'] = async (\n    _lpAccount,\n    params,\n  ) => {\n    const message = new Cell();\n\n    message.bits.writeUint(DEX_OP_CODES.REFUND, 32);\n    message.bits.writeUint(params?.queryId ?? 0, 64);\n\n    return message;\n  };\n\n  public createDirectAddLiquidityBody: LpAccountRevision['createDirectAddLiquidityBody'] =\n    async (_lpAccount, params) => {\n      const message = new Cell();\n\n      message.bits.writeUint(DEX_OP_CODES.DIRECT_ADD_LIQUIDITY, 32);\n      message.bits.writeUint(params.queryId ?? 0, 64);\n      message.bits.writeCoins(new BN(params.amount0));\n      message.bits.writeCoins(new BN(params.amount1));\n      message.bits.writeCoins(new BN(params.minimumLpToMint ?? 1));\n\n      return message;\n    };\n\n  public createResetGasBody: LpAccountRevision['createResetGasBody'] = async (\n    _lpAccount,\n    params,\n  ) => {\n    const message = new Cell();\n\n    message.bits.writeUint(DEX_OP_CODES.RESET_GAS, 32);\n    message.bits.writeUint(params?.queryId ?? 0, 64);\n\n    return message;\n  };\n\n  public getData: LpAccountRevision['getData'] = async (lpAccount) => {\n    const contractAddress = await lpAccount.getAddress();\n    const result = await lpAccount.provider.call2(\n      contractAddress.toString(),\n      'get_lp_account_data',\n    );\n\n    return {\n      userAddress: parseAddress(result[0]),\n      poolAddress: parseAddress(result[1]),\n      amount0: result[2] as BN,\n      amount1: result[3] as BN,\n    };\n  };\n}\n","import TonWeb from 'tonweb';\n\nimport { ROUTER_REVISION } from '../constants';\nimport type {\n  Address,\n  Cell,\n  HttpProvider,\n  BN,\n  AddressType,\n  QueryIdType,\n  ContractOptions,\n  MessageData,\n  AmountType,\n} from '@/types';\n\nimport type {\n  LpAccountRevision,\n  LpAccountGasConstants,\n} from './LpAccountRevision';\nimport { LpAccountRevisionV1 } from './LpAccountRevisionV1';\n\nconst {\n  Contract,\n  utils: { BN },\n} = TonWeb;\n\nconst REVISIONS = {\n  [ROUTER_REVISION.V1]: LpAccountRevisionV1,\n} as const;\n\n/**\n * @type {LpAccountData} represent state of the lp account.\n *\n * @property {Address | null} userAddress - Owner's address\n * @property {Address | null} poolAddress - Pool's address\n * @property {BN} amount0 - Balance of the first Jetton token (in basic token units)\n * @property {BN} amount1 - Balance of the second Jetton token (in basic token units)\n */\nexport type LpAccountData = {\n  userAddress: Address | null;\n  poolAddress: Address | null;\n  amount0: BN;\n  amount1: BN;\n};\n\ninterface LpAccountOptions extends ContractOptions {\n  revision: LpAccountRevision | keyof typeof REVISIONS;\n  address: AddressType;\n}\n\n/**\n * @type {LpAccount} represents the lp account contract and provide methods to interact with it.\n *\n * The lp account contract holds information about the liquidity provided by the user before minting new liquidity.\n * It interacts only with a single pool contract. For each user, there is single account contract for each pool.\n * The router “routes” the temporary liquidity to the correct account contract.\n * Then the account contract calls the pool contract again to mint new liquidity (once it satisfies some requirements).\n */\nexport class LpAccount extends Contract {\n  private revision: LpAccountRevision;\n\n  constructor(\n    provider: HttpProvider,\n    { revision, ...options }: LpAccountOptions,\n  ) {\n    super(provider, options);\n\n    if (typeof revision === 'string') {\n      if (!REVISIONS[revision])\n        throw Error(`Unknown account revision: ${revision}`);\n\n      this.revision = new REVISIONS[revision]();\n    } else {\n      this.revision = revision;\n    }\n  }\n\n  public get gasConstants(): LpAccountGasConstants {\n    return this.revision.gasConstants;\n  }\n\n  /**\n   * Create a payload for the `refund_me` transaction.\n   *\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {Cell} payload for the `refund_me` transaction.\n   */\n  public async createRefundBody(params?: {\n    queryId?: QueryIdType;\n  }): Promise<Cell> {\n    return this.revision.createRefundBody(this, params);\n  }\n\n  /**\n   * Create a payload for the `direct_add_liquidity` transaction.\n   *\n   * @param {BN | number} params.amount0 - Amount of the first Jetton tokens (in basic token units)\n   * @param {BN | number} params.amount1 - Amount of the second Jetton tokens (in basic token units)\n   * @param {BN | number | undefined} params.minimumLpToMint - Optional; minimum amount of received liquidity tokens (in basic token units)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {Cell} payload for the `direct_add_liquidity` transaction.\n   */\n  public async createDirectAddLiquidityBody(params: {\n    amount0: AmountType;\n    amount1: AmountType;\n    minimumLpToMint?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<Cell> {\n    return this.revision.createDirectAddLiquidityBody(this, params);\n  }\n\n  /**\n   * Create a payload for the `reset_gas` transaction.\n   *\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {Cell} payload for the `reset_gas` transaction.\n   */\n  public async createResetGasBody(params?: {\n    queryId?: QueryIdType;\n  }): Promise<Cell> {\n    return this.revision.createResetGasBody(this, params);\n  }\n\n  /**\n   * @returns {LpAccountData} structure containing current state of the lp account.\n   */\n  public async getData(): Promise<LpAccountData> {\n    return await this.revision.getData(this);\n  }\n\n  /**\n   * Build all data required to execute a `refund_me` transaction.\n   *\n   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} all data required to execute a `refund_me` transaction.\n   */\n  public async buildRefundTxParams(params?: {\n    gasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const to = await this.getAddress();\n\n    const payload = await this.createRefundBody({ queryId: params?.queryId });\n\n    const gasAmount = new BN(params?.gasAmount ?? this.gasConstants.refund);\n\n    return { to, payload, gasAmount };\n  }\n\n  /**\n   * Build all data required to execute a `direct_add_liquidity` transaction.\n   *\n   * @param {BN | number} params.amount0 - Amount of the first Jetton tokens (in basic token units)\n   * @param {BN | number} params.amount1 - Amount of the second Jetton tokens (in basic token units)\n   * @param {BN | number | undefined} params.minimumLpToMint - Optional; minimum amount of received liquidity tokens (in basic token units)\n   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} all data required to execute a `direct_add_liquidity` transaction.\n   */\n  public async buildDirectAddLiquidityTxParams(params: {\n    amount0: AmountType;\n    amount1: AmountType;\n    minimumLpToMint?: AmountType;\n    gasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const to = await this.getAddress();\n\n    const payload = await this.createDirectAddLiquidityBody({\n      amount0: params.amount0,\n      amount1: params.amount1,\n      minimumLpToMint: params.minimumLpToMint,\n      queryId: params.queryId,\n    });\n\n    const gasAmount = new BN(params.gasAmount ?? this.gasConstants.directAddLp);\n\n    return { to, payload, gasAmount };\n  }\n\n  /**\n   * Build all data required to execute a `reset_gas` transaction.\n   *\n   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} all data required to execute a `reset_gas` transaction.\n   */\n  public async buildResetGasTxParams(params?: {\n    gasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const to = await this.getAddress();\n\n    const payload = await this.createResetGasBody({ queryId: params?.queryId });\n\n    const gasAmount = new BN(params?.gasAmount ?? this.gasConstants.resetGas);\n\n    return { to, payload, gasAmount };\n  }\n}\n","import TonWeb from 'tonweb';\n\nimport { LpAccountRevisionV1 } from '../lp-account/LpAccountRevisionV1';\nimport { parseAddress } from '@/utils/parseAddress';\nimport { DEX_OP_CODES } from '../constants';\nimport type { Address, Cell, BN } from '@/types';\n\nimport type { PoolRevision } from './PoolRevision';\n\nconst {\n  utils: { BN, bytesToBase64 },\n  boc: { Cell },\n  Address,\n} = TonWeb;\n\nexport class PoolRevisionV1 implements PoolRevision {\n  public get gasConstants(): PoolRevision['gasConstants'] {\n    return {\n      collectFees: new BN(1100000000),\n      burn: new BN(500000000),\n    };\n  }\n\n  public createCollectFeesBody: PoolRevision['createCollectFeesBody'] = async (\n    _pool,\n    params,\n  ) => {\n    const message = new Cell();\n\n    message.bits.writeUint(DEX_OP_CODES.COLLECT_FEES, 32);\n    message.bits.writeUint(params?.queryId ?? 0, 64);\n\n    return message;\n  };\n\n  public createBurnBody: PoolRevision['createBurnBody'] = async (\n    _pool,\n    params,\n  ) => {\n    const message = new Cell();\n\n    message.bits.writeUint(DEX_OP_CODES.REQUEST_BURN, 32);\n    message.bits.writeUint(params.queryId ?? 0, 64);\n    message.bits.writeCoins(new BN(params.amount));\n    message.bits.writeAddress(new Address(params.responseAddress));\n\n    return message;\n  };\n\n  public getExpectedOutputs: PoolRevision['getExpectedOutputs'] = async (\n    pool,\n    params,\n  ) => {\n    const cell = new Cell();\n\n    cell.bits.writeAddress(new Address(params.jettonWallet));\n\n    const slice = bytesToBase64(await cell.toBoc(false));\n\n    const poolAddress = await pool.getAddress();\n    const result = await pool.provider.call2(\n      poolAddress.toString(),\n      'get_expected_outputs',\n      [\n        ['int', params.amount.toString()],\n        ['tvm.Slice', slice],\n      ],\n    );\n\n    return {\n      jettonToReceive: result[0] as BN,\n      protocolFeePaid: result[1] as BN,\n      refFeePaid: result[2] as BN,\n    };\n  };\n\n  public getExpectedTokens: PoolRevision['getExpectedTokens'] = async (\n    pool,\n    params,\n  ) => {\n    const poolAddress = await pool.getAddress();\n    const result = await pool.provider.call2(\n      poolAddress.toString(),\n      'get_expected_tokens',\n      [\n        ['int', params.amount0.toString()],\n        ['int', params.amount1.toString()],\n      ],\n    );\n\n    return result as BN;\n  };\n\n  public getExpectedLiquidity: PoolRevision['getExpectedLiquidity'] = async (\n    pool,\n    params,\n  ) => {\n    const poolAddress = await pool.getAddress();\n    const result = await pool.provider.call2(\n      poolAddress.toString(),\n      'get_expected_liquidity',\n      [['int', params.jettonAmount.toString()]],\n    );\n\n    return {\n      amount0: result[0] as BN,\n      amount1: result[1] as BN,\n    };\n  };\n\n  public getLpAccountAddress: PoolRevision['getLpAccountAddress'] = async (\n    pool,\n    params,\n  ) => {\n    const cell = new Cell();\n\n    cell.bits.writeAddress(new Address(params.ownerAddress));\n\n    const slice = bytesToBase64(await cell.toBoc(false));\n    const poolAddress = await pool.getAddress();\n\n    const result = await pool.provider.call2(\n      poolAddress.toString(),\n      'get_lp_account_address',\n      [['tvm.Slice', slice]],\n    );\n\n    return parseAddress(result);\n  };\n\n  public constructLpAccountRevision: PoolRevision['constructLpAccountRevision'] =\n    (_pool) => new LpAccountRevisionV1();\n\n  public getData: PoolRevision['getData'] = async (pool) => {\n    const contractAddress = await pool.getAddress();\n\n    const result = await pool.provider.call2(\n      contractAddress.toString(),\n      'get_pool_data',\n    );\n\n    return {\n      reserve0: result[0] as BN,\n      reserve1: result[1] as BN,\n      token0WalletAddress: parseAddress(result[2]),\n      token1WalletAddress: parseAddress(result[3]),\n      lpFee: result[4] as BN,\n      protocolFee: result[5] as BN,\n      refFee: result[6] as BN,\n      protocolFeeAddress: parseAddress(result[7]),\n      collectedToken0ProtocolFee: result[8] as BN,\n      collectedToken1ProtocolFee: result[9] as BN,\n    };\n  };\n}\n","import TonWeb from 'tonweb';\n\nimport { LpAccount } from '../lp-account/LpAccount';\nimport { ROUTER_REVISION } from '../constants';\nimport type {\n  Address,\n  Cell,\n  HttpProvider,\n  JettonMinter,\n  JettonWallet,\n  BN,\n  AddressType,\n  QueryIdType,\n  JettonMinterOptions,\n  MessageData,\n  AmountType,\n} from '@/types';\n\nimport { PoolGasConstants, PoolRevision } from './PoolRevision';\nimport { PoolRevisionV1 } from './PoolRevisionV1';\n\nconst {\n  Address,\n  utils: { BN },\n  token: {\n    jetton: { JettonMinter, JettonWallet },\n  },\n} = TonWeb;\n\nconst REVISIONS = {\n  [ROUTER_REVISION.V1]: PoolRevisionV1,\n} as const;\n\n/**\n * @type {PoolData} state of the pool: Jetton token reserves, Jetton wallet addresses and fee parameters.\n *\n * @property {BN} reserve0 - Amount of the first token (in basic token units)\n * @property {BN} reserve1 - Amount of the second token (in basic token units)\n * @property {Address | null} token0WalletAddress - Address of the first Jetton token\n * @property {Address | null} token1WalletAddress - Address of the second Jetton token\n * @property {BN} lpFee - Liquidity pool fee value\n * @property {BN} protocolFee - Protocol fee\n * @property {BN} refFee - Referral fee\n * @property {Address | null} protocolFeeAddress - Address for receiving protocol fees\n * @property {BN} collectedToken0ProtocolFee - Amount of collected protocol fees of the first token (in basic token units)\n * @property {BN} collectedToken1ProtocolFee - Amount of collected protocol fees of the second token (in basic token units)\n */\nexport type PoolData = {\n  reserve0: BN;\n  reserve1: BN;\n  token0WalletAddress: Address | null;\n  token1WalletAddress: Address | null;\n  lpFee: BN;\n  protocolFee: BN;\n  refFee: BN;\n  protocolFeeAddress: Address | null;\n  collectedToken0ProtocolFee: BN;\n  collectedToken1ProtocolFee: BN;\n};\n\n/**\n * @type {ExpectedOutputsData}\n *\n * @property {BN} jettonToReceive - Amount of tokens received (in basic token units)\n * @property {BN} protocolFeePaid - Amount tokens paid for protocol fees (in basic token units)\n * @property {BN} refFeePaid - Amount tokens paid for referral fees (in basic token units)\n */\nexport type ExpectedOutputsData = {\n  jettonToReceive: BN;\n  protocolFeePaid: BN;\n  refFeePaid: BN;\n};\n\n/**\n * @type {PoolAmountsData}\n *\n * @property {BN} amount0 - Amount of tokens for the first Jetton (in basic token units)\n * @property {BN} amount1 - Amount of tokens for the second Jetton (in basic token units)\n */\nexport type PoolAmountsData = {\n  amount0: BN;\n  amount1: BN;\n};\n\ninterface PoolOptions extends JettonMinterOptions {\n  revision: PoolRevision | keyof typeof REVISIONS;\n  address: AddressType;\n}\n\n/**\n * @type {Pool} represents the pool contract and provide methods to interact with it.\n *\n * The pool is the contract that stores the AMM data for a certain pair and is responsible for handling “swaps” or providing liquidity for a certain pool.\n * For each pair (e.g. WTON/USDT), there is only a single pool contract.\n * The pool is also a Jetton Minter, and handles minting/burning of Liquidity Provider Jettons.\n * All the swap/lp calculations are done in the pool contract.\n */\nexport class Pool extends JettonMinter {\n  private revision: PoolRevision;\n\n  constructor(provider: HttpProvider, { revision, ...options }: PoolOptions) {\n    super(provider, options);\n\n    if (typeof revision === 'string') {\n      if (!REVISIONS[revision])\n        throw Error(`Unknown pool revision: ${revision}`);\n\n      this.revision = new REVISIONS[revision]();\n    } else {\n      this.revision = revision;\n    }\n  }\n\n  public get gasConstants(): PoolGasConstants {\n    return this.revision.gasConstants;\n  }\n\n  /**\n   * Create a payload for the `collect_fees` transaction.\n   *\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {Cell} payload for the `collect_fees` transaction.\n   */\n  public async createCollectFeesBody(params?: {\n    queryId?: QueryIdType;\n  }): Promise<Cell> {\n    return this.revision.createCollectFeesBody(this, params);\n  }\n\n  /**\n   * Create a payload for the `burn` transaction.\n   *\n   * @param {BN | number} params.amount - Amount of lp tokens to burn (in basic token units)\n   * @param {Address | string} params.responseAddress - Address of a user\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {Cell} payload for the `burn` transaction.\n   */\n  public async createBurnBody(params: {\n    amount: AmountType;\n    responseAddress: AddressType;\n    queryId?: QueryIdType;\n  }): Promise<Cell> {\n    return this.revision.createBurnBody(this, params);\n  }\n\n  /**\n   * Estimate expected result of the amount of jettonWallet tokens swapped to the other type of tokens of the pool\n   *\n   * @param {BN | number} params.amount - Amount of tokens to swap (in basic token units)\n   * @param {Address | string} params.jettonWallet - Token Jetton address (must be equal to one of the Jetton addresses of the pool)\n   *\n   * @returns {ExpectedOutputsData} structure with expected result of a token swap\n   */\n  public async getExpectedOutputs(params: {\n    amount: AmountType;\n    jettonWallet: AddressType;\n  }): Promise<ExpectedOutputsData> {\n    return this.revision.getExpectedOutputs(this, params);\n  }\n\n  /**\n   * Estimate an expected amount of lp tokens minted when providing liquidity.\n   *\n   * @param {BN | number} params.amount0 - Amount of tokens for the first Jetton (in basic token units)\n   * @param {BN | number} params.amount1 - Amount of tokens for the second Jetton (in basic token units)\n   *\n   * @returns {BN} an estimated amount of liquidity tokens to be minted\n   */\n  public async getExpectedTokens(params: {\n    amount0: AmountType;\n    amount1: AmountType;\n  }): Promise<BN> {\n    return this.revision.getExpectedTokens(this, params);\n  }\n\n  /**\n   * Estimate expected liquidity freed upon burning liquidity tokens.\n   *\n   * @param {BN | number} params.jettonAmount - Amount of liquidity tokens (in basic token units)\n   *\n   * @returns {PoolAmountsData} structure with expected freed liquidity\n   */\n  public async getExpectedLiquidity(params: {\n    jettonAmount: AmountType;\n  }): Promise<PoolAmountsData> {\n    return this.revision.getExpectedLiquidity(this, params);\n  }\n\n  /**\n   * @param {Address | string} params.ownerAddress - Address of a user\n   *\n   * @returns a JettonWallet object for an address returned by getJettonWalletAddress\n   */\n  public async getJettonWallet(params: {\n    ownerAddress: AddressType;\n  }): Promise<JettonWallet> {\n    const poolWalletAddress = await this.getJettonWalletAddress(\n      new Address(params.ownerAddress),\n    );\n    return new JettonWallet(this.provider, { address: poolWalletAddress });\n  }\n\n  /**\n   * @param {Address | string} params.ownerAddress - Address of a user\n   *\n   * @returns the lp account address of a user\n   */\n  public async getLpAccountAddress(params: {\n    ownerAddress: AddressType;\n  }): Promise<Address | null> {\n    return await this.revision.getLpAccountAddress(this, params);\n  }\n\n  /**\n   * @param {Address | string} params.ownerAddress - Address of a user\n   *\n   * @returns {LpAccount} object for address returned by getLpAccountAddress\n   */\n  public async getLpAccount(params: {\n    ownerAddress: AddressType;\n  }): Promise<LpAccount | null> {\n    const accountAddress = await this.getLpAccountAddress(params);\n\n    if (!accountAddress) return null;\n\n    return new LpAccount(this.provider, {\n      address: accountAddress,\n      revision: this.revision.constructLpAccountRevision(this),\n    });\n  }\n\n  /**\n   * @returns {PoolData} containing current state of the pool\n   */\n  public async getData(): Promise<PoolData> {\n    return this.revision.getData(this);\n  }\n\n  /**\n   * Build all data required to execute a `collect_fees` transaction.\n   *\n   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} all data required to execute a `collect_fees` transaction.\n   */\n  public async buildCollectFeeTxParams(params?: {\n    gasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const to = await this.getAddress();\n\n    const payload = await this.createCollectFeesBody({\n      queryId: params?.queryId,\n    });\n\n    const gasAmount = new BN(\n      params?.gasAmount ?? this.gasConstants.collectFees,\n    );\n\n    return { to, payload, gasAmount };\n  }\n\n  /**\n   * Build all data required to execute a `burn` transaction.\n   *\n   * @param {BN | number} params.amount - Amount of lp tokens to burn (in basic token units)\n   * @param {Address | string} params.responseAddress - Address of a user\n   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} all data required to execute a `burn` transaction.\n   */\n  public async buildBurnTxParams(params: {\n    amount: AmountType;\n    responseAddress: AddressType;\n    gasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const to = await this.getJettonWalletAddress(\n      new Address(params.responseAddress),\n    );\n\n    const payload = await this.createBurnBody({\n      amount: params.amount,\n      responseAddress: params.responseAddress,\n      queryId: params.queryId,\n    });\n\n    const gasAmount = new BN(params?.gasAmount ?? this.gasConstants.burn);\n\n    return { to, payload, gasAmount };\n  }\n}\n","import TonWeb from 'tonweb';\n\nimport type { AddressType, QueryIdType, AmountType, Cell } from '@/types';\n\nconst {\n  utils: { BN },\n  boc: { Cell },\n  Address,\n} = TonWeb;\n\n/**\n * Implements `transfer` function from Jettons Standard.\n * [Docs](https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md#1-transfer)\n *\n * ```TL-B\n * transfer#0f8a7ea5 query_id:uint64 amount:(VarUInteger 16) destination:MsgAddress response_destination:MsgAddress custom_payload:(Maybe ^Cell) forward_ton_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell) = InternalMsgBody;\n * ```\n */\nexport function createJettonTransferMessage(params: {\n  queryId: QueryIdType;\n  amount: AmountType;\n  destination: AddressType;\n  responseDestination?: AddressType;\n  customPayload?: Cell;\n  forwardTonAmount: AmountType;\n  forwardPayload?: Cell;\n}) {\n  const message = new Cell();\n\n  message.bits.writeUint(0xf8a7ea5, 32);\n  message.bits.writeUint(params.queryId, 64);\n  message.bits.writeCoins(new BN(params.amount));\n  message.bits.writeAddress(new Address(params.destination));\n  message.bits.writeAddress(\n    params.responseDestination\n      ? new Address(params.responseDestination)\n      : undefined,\n  );\n\n  if (params.customPayload) {\n    message.refs.push(params.customPayload);\n    message.bits.writeBit(true);\n  } else {\n    message.bits.writeBit(false);\n  }\n\n  message.bits.writeCoins(new BN(params.forwardTonAmount));\n\n  if (params.forwardPayload) {\n    message.refs.push(params.forwardPayload);\n    message.bits.writeBit(true);\n  } else {\n    message.bits.writeBit(false);\n  }\n\n  return message;\n}\n","import type { BN } from '@/types';\n\n/**\n * [Docs](https://docs.ton.org/develop/func/types#absence-of-boolean-type)\n *\n * In FunC, booleans are represented as integers;\n * false is represented as 0 and true is represented as -1 (257 ones in binary notation).\n * When a condition is checked, every non-zero integer is considered a true value.\n */\nexport function parseBoolean(bn: BN) {\n  return !bn.isZero();\n}\n","import TonWeb from 'tonweb';\n\nimport { PoolRevisionV1 } from '../pool/PoolRevisionV1';\nimport { parseAddress } from '@/utils/parseAddress';\nimport { DEX_OP_CODES } from '../constants';\nimport type { Cell, BN } from '@/types';\nimport { parseBoolean } from '@/utils/parseBoolean';\n\nimport type { RouterRevision } from './RouterRevision';\n\nconst {\n  Address,\n  utils: { BN, bytesToBase64 },\n  boc: { Cell },\n} = TonWeb;\n\nexport class RouterRevisionV1 implements RouterRevision {\n  public get gasConstants(): RouterRevision['gasConstants'] {\n    return {\n      swap: new BN(300000000),\n      provideLp: new BN(300000000),\n      swapForward: new BN(265000000),\n      provideLpForward: new BN(265000000),\n    };\n  }\n\n  public createSwapBody: RouterRevision['createSwapBody'] = async (\n    _router,\n    params,\n  ) => {\n    const payload = new Cell();\n\n    payload.bits.writeUint(DEX_OP_CODES.SWAP, 32);\n    payload.bits.writeAddress(new Address(params.askJettonWalletAddress));\n    payload.bits.writeCoins(new BN(params.minAskAmount));\n    payload.bits.writeAddress(new Address(params.userWalletAddress));\n\n    if (params.referralAddress) {\n      payload.bits.writeUint(1, 1);\n      payload.bits.writeAddress(new Address(params.referralAddress));\n    } else {\n      payload.bits.writeUint(0, 1);\n    }\n\n    return payload;\n  };\n\n  public createProvideLiquidityBody: RouterRevision['createProvideLiquidityBody'] =\n    async (_router, params) => {\n      const payload = new Cell();\n\n      payload.bits.writeUint(DEX_OP_CODES.PROVIDE_LIQUIDITY, 32);\n      payload.bits.writeAddress(new Address(params.routerWalletAddress));\n      payload.bits.writeCoins(new BN(params.minLpOut));\n\n      return payload;\n    };\n\n  public getPoolAddress: RouterRevision['getPoolAddress'] = async (\n    router,\n    params,\n  ) => {\n    const cellA = new Cell();\n    cellA.bits.writeAddress(new Address(params.token0));\n\n    const cellB = new Cell();\n    cellB.bits.writeAddress(new Address(params.token1));\n\n    const sliceA = bytesToBase64(await cellA.toBoc(false));\n    const sliceB = bytesToBase64(await cellB.toBoc(false));\n\n    const routerAddress = await router.getAddress();\n    const result = await router.provider.call2(\n      routerAddress.toString(),\n      'get_pool_address',\n      [\n        ['tvm.Slice', sliceA],\n        ['tvm.Slice', sliceB],\n      ],\n    );\n\n    return parseAddress(result);\n  };\n\n  public getData: RouterRevision['getData'] = async (router) => {\n    const routerAddress = await router.getAddress();\n    const result = await router.provider.call2(\n      routerAddress.toString(),\n      'get_router_data',\n      [],\n    );\n\n    return {\n      isLocked: parseBoolean(result[0]),\n      adminAddress: parseAddress(result[1] as Cell),\n      tempUpgrade: result[2] as Cell,\n      poolCode: result[3] as Cell,\n      jettonLpWalletCode: result[4] as Cell,\n      lpAccountCode: result[5] as Cell,\n    };\n  };\n\n  public constructPoolRevision: RouterRevision['constructPoolRevision'] = (\n    _router,\n  ) => new PoolRevisionV1();\n}\n","import TonWeb from 'tonweb';\n\nimport { Pool } from '../pool/Pool';\nimport { ROUTER_REVISION } from '../constants';\nimport { createJettonTransferMessage } from '@/utils/createJettonTransferMessage';\nimport type {\n  Address,\n  Cell,\n  Contract,\n  HttpProvider,\n  JettonMinter,\n  AddressType,\n  AmountType,\n  MessageData,\n  QueryIdType,\n  ContractOptions,\n} from '@/types';\n\nimport type { RouterGasConstants, RouterRevision } from './RouterRevision';\nimport { RouterRevisionV1 } from './RouterRevisionV1';\n\nconst {\n  Address,\n  Contract,\n  utils: { BN },\n  token: {\n    jetton: { JettonMinter },\n  },\n} = TonWeb;\n\nconst REVISIONS = {\n  [ROUTER_REVISION.V1]: RouterRevisionV1,\n} as const;\n\n/**\n * @type {RouterData} containing state of the router\n *\n * @property {boolean} isLocked - true if transfer_notification operations are locked (swap, provide_lp)\n * @property {Address} adminAddress - Address of contract's admin account\n * @property {Cell} tempUpgrade - A structure describing state of contract's code & admin upgrade; zero values indicate that no upgrade is pending\n * @property {Cell} poolCode - Code of the router's liquidity pool contract\n * @property {Cell} jettonLpWalletCode - Code of lp wallet contract\n * @property {Cell} lpAccountCode - Code of lp account contract\n */\nexport type RouterData = {\n  isLocked: boolean;\n  adminAddress: Address | null;\n  tempUpgrade: Cell;\n  poolCode: Cell;\n  jettonLpWalletCode: Cell;\n  lpAccountCode: Cell;\n};\n\ninterface RouterOptions extends ContractOptions {\n  address: AddressType;\n  revision: RouterRevision | keyof typeof REVISIONS;\n}\n\n/**\n * @type {Router} represents the router contract and provide methods to interact with it.\n *\n * The router is the contract that acts as an entrypoint for all DEX calls.\n * It is responsible for routing all Jetton calls with transfer_notification op to the correct pool contract.\n * It acts as a sovereign over the DEX, and can be used to lock/unlock trading on all pools,\n * to change fees on a certain pool or to upgrade its own contract. The router is the only contract that can be upgraded.\n * Each Jetton that goes through the DEX is owned by the router. The router does not store anything about pairs.\n */\nexport class Router extends Contract {\n  private revision: RouterRevision;\n\n  constructor(provider: HttpProvider, { revision, ...options }: RouterOptions) {\n    super(provider, options);\n\n    if (typeof revision === 'string') {\n      if (!REVISIONS[revision])\n        throw Error(`Unknown router revision: ${revision}`);\n\n      this.revision = new REVISIONS[revision]();\n    } else {\n      this.revision = revision;\n    }\n  }\n\n  public get gasConstants(): RouterGasConstants {\n    return this.revision.gasConstants;\n  }\n\n  /**\n   * Create a payload for the `swap` transaction.\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {BN | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)\n   * @param {Address | string} params.askJettonWalletAddress - Jetton router's wallet address of tokens to be received\n   * @param {Address | string | undefined} params.referralAddress - Optional; referral address\n   *\n   * @returns {Cell} payload for the `swap` transaction.\n   */\n  public async createSwapBody(params: {\n    userWalletAddress: AddressType;\n    minAskAmount: AmountType;\n    askJettonWalletAddress: AddressType;\n    referralAddress?: AddressType;\n  }): Promise<Cell> {\n    return this.revision.createSwapBody(this, params);\n  }\n\n  /**\n   * Create a payload for the `provide_lp` transaction.\n   *\n   * @param {Address | string} params.routerWalletAddress - Address of the router's Jetton token wallet\n   * @param {BN | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)\n   *\n   * @returns payload for the `provide_lp` transaction.\n   */\n  public async createProvideLiquidityBody(params: {\n    routerWalletAddress: AddressType;\n    minLpOut: AmountType;\n  }): Promise<Cell> {\n    return this.revision.createProvideLiquidityBody(this, params);\n  }\n\n  /**\n   * **Note:** It's necessary to specify addresses of Jetton wallets of the router as the arguments of this method.\n   * These addresses can be retrieved with getJettonWalletAddress of the Jetton minter.\n   * @param {Address | string} params.token0 - The address of the router's wallet of first Jetton\n   * @param {Address | string} params.token1 - The address of the router's wallet of second Jetton\n   *\n   * @returns {Address | null} an address of a pool for a specified pair of assets.\n   */\n  public async getPoolAddress(params: {\n    token0: AddressType;\n    token1: AddressType;\n  }): Promise<Address | null> {\n    return this.revision.getPoolAddress(this, params);\n  }\n\n  /**\n   * @param {[Address | string, Address | string]} params.jettonAddresses - Tuple of Jetton addresses of a pool\n   *\n   * @returns {Pool} object for a pool with specified Jetton token addresses.\n   */\n  public async getPool(params: {\n    jettonAddresses: [AddressType, AddressType];\n  }): Promise<Pool | null> {\n    const jetton0 = new JettonMinter(\n      this.provider,\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      {\n        address: params.jettonAddresses[0],\n      },\n    );\n\n    const jetton1 = new JettonMinter(\n      this.provider,\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      {\n        address: params.jettonAddresses[1],\n      },\n    );\n\n    const routerAddress = await this.getAddress();\n    const jetton0WalletAddress = await jetton0.getJettonWalletAddress(\n      routerAddress,\n    );\n    const jetton1WalletAddress = await jetton1.getJettonWalletAddress(\n      routerAddress,\n    );\n\n    const poolAddress = await this.getPoolAddress({\n      token0: jetton0WalletAddress,\n      token1: jetton1WalletAddress,\n    });\n\n    if (!poolAddress) return null;\n\n    return new Pool(\n      this.provider,\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      {\n        address: poolAddress,\n        revision: this.revision.constructPoolRevision(this),\n      },\n    );\n  }\n\n  /**\n   * @returns {RouterData} containing current state of the router.\n   */\n  public async getData(): Promise<RouterData> {\n    return await this.revision.getData(this);\n  }\n\n  /**\n   * Build all data required to execute a jetton `swap` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.offerJettonAddress - Jetton address of a token to be swapped\n   * @param {Address | string} params.askJettonAddress - Jetton address of a token to be received\n   * @param {BN | number} params.offerAmount - Amount of tokens to be swapped (in basic token units)\n   * @param {BN | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)\n   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)\n   * @param {BN | number | undefined} params.forwardGasAmount - Optional; forward amount of gas for the next transaction (in nanoTons)\n   * @param {Address | string | undefined} params.referralAddress - Optional; referral address\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} data required to execute a jetton `swap` transaction\n   */\n  public async buildSwapJettonTxParams(params: {\n    userWalletAddress: AddressType;\n    offerJettonAddress: AddressType;\n    askJettonAddress: AddressType;\n    offerAmount: AmountType;\n    minAskAmount: AmountType;\n    gasAmount?: AmountType;\n    forwardGasAmount?: AmountType;\n    referralAddress?: AddressType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const offerJetton = new JettonMinter(\n      this.provider,\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      {\n        address: params.offerJettonAddress,\n      },\n    );\n\n    const askJetton = new JettonMinter(\n      this.provider,\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      {\n        address: params.askJettonAddress,\n      },\n    );\n\n    const offerJettonWalletAddress = await offerJetton.getJettonWalletAddress(\n      new Address(params.userWalletAddress),\n    );\n    const askJettonWalletAddress = await askJetton.getJettonWalletAddress(\n      await this.getAddress(),\n    );\n\n    const forwardPayload = await this.createSwapBody({\n      userWalletAddress: params.userWalletAddress,\n      minAskAmount: params.minAskAmount,\n      askJettonWalletAddress: askJettonWalletAddress,\n      referralAddress: params.referralAddress,\n    });\n\n    const forwardTonAmount = new BN(\n      params.forwardGasAmount ?? this.gasConstants.swapForward,\n    );\n\n    const payload = createJettonTransferMessage({\n      queryId: params.queryId ?? 0,\n      amount: params.offerAmount,\n      destination: await this.getAddress(),\n      forwardTonAmount,\n      forwardPayload,\n    });\n\n    const gasAmount = new BN(params.gasAmount ?? this.gasConstants.swap);\n\n    return {\n      to: offerJettonWalletAddress,\n      payload,\n      gasAmount,\n    };\n  }\n\n  /**\n   * Build all data required to execute a ton to jetton `swap` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.proxyTonAddress - Address of a proxy ton contract\n   * @param {Address | string} params.askJettonAddress - Jetton address of a token to be received\n   * @param {BN | number} params.offerAmount - Amount of ton to be swapped (in nanoTons)\n   * @param {BN | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)\n   * @param {BN | number | undefined} params.forwardGasAmount - Optional; forward amount of gas for the next transaction (in nanoTons)\n   * @param {Address | string | undefined} params.referralAddress - Optional; referral address\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} data required to execute a ton to jetton `swap` transaction\n   */\n  public async buildSwapProxyTonTxParams(params: {\n    userWalletAddress: AddressType;\n    proxyTonAddress: AddressType;\n    askJettonAddress: AddressType;\n    offerAmount: AmountType;\n    minAskAmount: AmountType;\n    forwardGasAmount?: AmountType;\n    referralAddress?: AddressType | undefined;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const proxyTonMinter = new JettonMinter(\n      this.provider,\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      {\n        address: params.proxyTonAddress,\n      },\n    );\n\n    const askJettonMinter = new JettonMinter(\n      this.provider,\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      {\n        address: params.askJettonAddress,\n      },\n    );\n\n    const proxyTonWalletAddress = await proxyTonMinter.getJettonWalletAddress(\n      await this.getAddress(),\n    );\n    const askJettonWalletAddress = await askJettonMinter.getJettonWalletAddress(\n      await this.getAddress(),\n    );\n\n    const forwardPayload = await this.createSwapBody({\n      userWalletAddress: params.userWalletAddress,\n      minAskAmount: params.minAskAmount,\n      askJettonWalletAddress: askJettonWalletAddress,\n      referralAddress: params.referralAddress,\n    });\n\n    const forwardTonAmount = new BN(\n      params.forwardGasAmount ?? this.gasConstants.swapForward,\n    );\n\n    const payload = createJettonTransferMessage({\n      queryId: params.queryId ?? 0,\n      amount: params.offerAmount,\n      destination: await this.getAddress(),\n      forwardTonAmount,\n      forwardPayload,\n    });\n\n    const gasAmount = new BN(params.offerAmount).add(forwardTonAmount);\n\n    return {\n      to: proxyTonWalletAddress,\n      payload,\n      gasAmount,\n    };\n  }\n\n  /**\n   * Collect all data required to execute a jetton `provide_lp` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.sendTokenAddress - Address of the provided Jetton token\n   * @param {Address | string} params.otherTokenAddress - Address of the other Jetton token in pair\n   * @param {BN | number} params.sendAmount - Amount of the first token deposited as liquidity (in basic token units)\n   * @param {BN | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)\n   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)\n   * @param {BN | number | undefined} params.forwardGasAmount - Optional; forward amount of gas for the next transaction (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} data required to execute a jetton `provide_lp` transaction\n   */\n  public async buildProvideLiquidityJettonTxParams(params: {\n    userWalletAddress: AddressType;\n    sendTokenAddress: AddressType;\n    otherTokenAddress: AddressType;\n    sendAmount: AmountType;\n    minLpOut: AmountType;\n    gasAmount?: AmountType;\n    forwardGasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const sendJettonMinter = new JettonMinter(\n      this.provider,\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      {\n        address: params.sendTokenAddress,\n      },\n    );\n\n    const otherJettonMinter = new JettonMinter(\n      this.provider,\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      {\n        address: params.otherTokenAddress,\n      },\n    );\n\n    const jettonWalletAddress = await sendJettonMinter.getJettonWalletAddress(\n      new Address(params.userWalletAddress),\n    );\n    const routerWalletAddress = await otherJettonMinter.getJettonWalletAddress(\n      await this.getAddress(),\n    );\n\n    const forwardPayload = await this.createProvideLiquidityBody({\n      routerWalletAddress: routerWalletAddress,\n      minLpOut: params.minLpOut,\n    });\n\n    const forwardTonAmount = new BN(\n      params.forwardGasAmount ?? this.gasConstants.provideLpForward,\n    );\n\n    const payload = createJettonTransferMessage({\n      queryId: params.queryId ?? 0,\n      amount: params.sendAmount,\n      destination: await this.getAddress(),\n      forwardTonAmount,\n      forwardPayload,\n    });\n\n    const gasAmount = new BN(params.gasAmount ?? this.gasConstants.provideLp);\n\n    return {\n      to: jettonWalletAddress,\n      payload,\n      gasAmount,\n    };\n  }\n\n  /**\n   * Collect all data required to execute a proxy ton `provide_lp` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.proxyTonAddress - Address of a proxy ton contract\n   * @param {Address | string} params.otherTokenAddress - Address of the other Jetton token in pair\n   * @param {BN | number} params.sendAmount - Amount of ton deposited as liquidity (in nanoTons)\n   * @param {BN | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)\n   * @param {BN | number | undefined} params.forwardGasAmount - Optional; forward amount of gas for the next transaction (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} data required to execute a proxy ton `provide_lp` transaction\n   */\n  public async buildProvideLiquidityProxyTonTxParams(params: {\n    userWalletAddress: AddressType;\n    proxyTonAddress: AddressType;\n    otherTokenAddress: AddressType;\n    sendAmount: AmountType;\n    minLpOut: AmountType;\n    forwardGasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const tonProxyMinter = new JettonMinter(\n      this.provider,\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      {\n        address: params.proxyTonAddress,\n      },\n    );\n\n    const otherJettonMinter = new JettonMinter(\n      this.provider,\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      {\n        address: params.otherTokenAddress,\n      },\n    );\n\n    const proxyTonWalletAddress = await tonProxyMinter.getJettonWalletAddress(\n      await this.getAddress(),\n    );\n    const routerWalletAddress = await otherJettonMinter.getJettonWalletAddress(\n      await this.getAddress(),\n    );\n\n    const forwardPayload = await this.createProvideLiquidityBody({\n      routerWalletAddress: routerWalletAddress,\n      minLpOut: params.minLpOut,\n    });\n\n    const forwardTonAmount = new BN(\n      params.forwardGasAmount ?? this.gasConstants.provideLp,\n    );\n\n    const payload = createJettonTransferMessage({\n      queryId: params.queryId ?? 0,\n      amount: params.sendAmount,\n      destination: await this.getAddress(),\n      forwardTonAmount,\n      forwardPayload,\n    });\n\n    const gasAmount = new BN(params.sendAmount).add(forwardTonAmount);\n\n    return {\n      to: proxyTonWalletAddress,\n      payload,\n      gasAmount,\n    };\n  }\n}\n","export const FARM_OP_CODES = {\n  STAKE: 0x6ec9dc65,\n  CLAIM_REWARDS: 0x78d9f109,\n  UNSTAKE: 0xb92965a0,\n} as const;\n\nexport const FARM_REVISION = {\n  V2: 'V2',\n} as const;\n","import type { Cell } from '@/types';\n\nexport function parseString(cell: Cell) {\n  const decoder = new TextDecoder();\n  return decoder.decode(cell.bits.getTopUppedArray());\n}\n","import TonWeb from 'tonweb';\n\nimport type { Cell, BN } from '@/types';\nimport { FARM_OP_CODES } from '../constants';\nimport { parseAddress } from '@/utils/parseAddress';\nimport { parseBoolean } from '@/utils/parseBoolean';\nimport { parseString } from '@/utils/parseString';\n\nimport type { FarmNftMinterRevision } from './FarmNftMinterRevision';\n\nconst {\n  utils: { BN },\n  boc: { Cell },\n} = TonWeb;\n\nexport class FarmNftMinterRevisionV2 implements FarmNftMinterRevision {\n  public get gasConstants(): FarmNftMinterRevision['gasConstants'] {\n    return {\n      stake: new BN(300000000),\n      stakeForward: new BN(250000000),\n    };\n  }\n\n  public createStakeBody: FarmNftMinterRevision['createStakeBody'] = async (\n    _minter,\n  ) => {\n    const payload = new Cell();\n\n    payload.bits.writeUint(FARM_OP_CODES.STAKE, 32);\n\n    return payload;\n  };\n\n  public getPendingData: FarmNftMinterRevision['getPendingData'] = async (\n    minter,\n  ) => {\n    const contractAddress = await minter.getAddress();\n\n    const result = await minter.provider.call2(\n      contractAddress.toString(),\n      'get_pending_data',\n    );\n\n    return {\n      changeCustodianTs: result[0] as BN,\n      sendMsgTs: result[1] as BN,\n      codeUpgradeTs: result[2] as BN,\n      newCustodian: parseAddress(result[3]),\n      pendingMsg: result[4] as Cell,\n      newCode: result[5] as Cell,\n      newStorage: result[6] as Cell,\n    };\n  };\n\n  public getVersion: FarmNftMinterRevision['getVersion'] = async (minter) => {\n    const contractAddress = await minter.getAddress();\n\n    const result = await minter.provider.call2(\n      contractAddress.toString(),\n      'get_version',\n    );\n\n    return {\n      major: result[0] as number,\n      minor: result[1] as number,\n      development: parseString(result[2]),\n    };\n  };\n\n  public getData: FarmNftMinterRevision['getData'] = async (minter) => {\n    const contractAddress = await minter.getAddress();\n\n    const result = await minter.provider.call2(\n      contractAddress.toString(),\n      'get_farming_minter_data',\n    );\n\n    const stakingTokenWallet = parseAddress(result[14]);\n\n    if (!stakingTokenWallet) {\n      throw new Error(\n        `Failed to parse stakingTokenWallet from cell: ${result[14]}`,\n      );\n    }\n\n    const rewardTokenWallet = parseAddress(result[15]);\n\n    if (!rewardTokenWallet) {\n      throw new Error(\n        `Failed to parse rewardTokenWallet from cell: ${result[15]}`,\n      );\n    }\n\n    return {\n      nextItemIndex: result[0] as BN,\n      lastUpdateTime: result[1] as BN,\n      status: result[2] as number,\n      depositedNanorewards: result[3] as BN,\n      currentStakedTokens: result[4] as BN,\n      accruedPerUnitNanorewards: result[5] as BN,\n      claimedFeeNanorewards: result[6] as BN,\n      accruedFeeNanorewards: result[7] as BN,\n      accruedNanorewards: result[8] as BN,\n      claimedNanorewards: result[9] as BN,\n      contractUniqueId: result[10] as BN,\n      nanorewardsPer24h: result[11] as BN,\n      adminFee: result[12] as BN,\n      minStakeTime: result[13] as BN,\n      stakingTokenWallet,\n      rewardTokenWallet,\n      custodianAddress: parseAddress(result[16]),\n      canChangeCustodian: parseBoolean(result[17]),\n      canSendRawMsg: parseBoolean(result[18]),\n      canChangeFee: parseBoolean(result[19]),\n      unrestrictedDepositRewards: parseBoolean(result[20]),\n\n      // NFTs are always soulbound in V2\n      soulboundItems: true,\n    };\n  };\n}\n","import TonWeb from 'tonweb';\n\nimport type {\n  Address,\n  Cell,\n  HttpProvider,\n  BN,\n  AddressType,\n  QueryIdType,\n  MessageData,\n  AmountType,\n  NftCollectionOptions,\n} from '@/types';\nimport { FARM_REVISION } from '../constants';\nimport { createJettonTransferMessage } from '@/utils/createJettonTransferMessage';\n\nimport type { FarmNftMinterRevision } from './FarmNftMinterRevision';\nimport { FarmNftMinterRevisionV2 } from './FarmNftMinterRevisionV2';\n\nconst {\n  Address,\n  utils: { BN },\n  token: {\n    nft: { NftCollection },\n    jetton: { JettonMinter, JettonWallet },\n  },\n} = TonWeb;\n\nconst REVISIONS = {\n  [FARM_REVISION.V2]: FarmNftMinterRevisionV2,\n} as const;\n\nexport type FarmNftMinterGasConstants = {\n  stake: BN;\n  stakeForward: BN;\n};\n\n/**\n * @typedef {Object} FarmNftMinterData\n *\n * @property {BN} nextItemIndex - Index of the next nft in this collection\n * @property {BN} lastUpdateTime - Last time farming values were updated\n * @property {number} status - Status of the contract: uninitialized `0`, active `1`, paused `3`\n * @property {BN} depositedNanorewards - Deposited rewards in nanounits\n * @property {BN} currentStakedTokens - Number of staked tokens in basic token units\n * @property {BN} accruedPerUnitNanorewards - Number of accrued nanorewards per basic stake token unit\n * @property {BN} claimedFeeNanorewards - Claimed fees @since V2 revision\n * @property {BN} accruedFeeNanorewards - Accrued fees @since V2 revision\n * @property {BN} accruedNanorewards - Total number of accrued rewards in nanounits\n * @property {BN} claimedNanorewards - Number of claimed rewards in nanounits\n * @property {BN} contractUniqueId - Minter id\n * @property {BN} nanorewardsPer24h - Total number of accrued rewards per 24h in nanounits\n * @property {BN} adminFee - Admin fee; divider is 10000 @since V2 revision\n * @property {Boolean} soulboundItems - Whether minted NFTs are soulbound\n * @property {BN} minStakeTime - Minimum staking time\n * @property {Address} stakingTokenWallet - Minter's staking jetton wallet\n * @property {Address} rewardTokenWallet - Minter's reward jetton wallet\n * @property {Address} custodianAddress - Custodian address @since V2 revision\n * @property {Boolean} canChangeCustodian - If can change custodian @since V2 revision\n * @property {Boolean} canSendRawMsg - If can send raw msg @since V2 revision\n * @property {Boolean} canChangeFee - If can change fee @since V2 revision\n * @property {Boolean} unrestrictedDepositRewards - If rewards can be deposited by anyone @since V2 revision\n */\nexport type FarmNftMinterData = {\n  nextItemIndex: BN;\n  lastUpdateTime: BN;\n  status: number;\n  depositedNanorewards: BN;\n  currentStakedTokens: BN;\n  accruedPerUnitNanorewards: BN;\n  claimedFeeNanorewards: BN;\n  accruedFeeNanorewards: BN;\n  accruedNanorewards: BN;\n  claimedNanorewards: BN;\n  contractUniqueId: BN;\n  nanorewardsPer24h: BN;\n  adminFee: BN;\n  soulboundItems: Boolean;\n  minStakeTime: BN;\n  stakingTokenWallet: Address;\n  rewardTokenWallet: Address;\n  custodianAddress: Address | null;\n  canChangeCustodian: Boolean;\n  canSendRawMsg: Boolean;\n  canChangeFee: Boolean;\n  unrestrictedDepositRewards: Boolean;\n};\n\n/**\n * @since V2 revision\n * @typedef {Object} PendingData\n *\n * @property {BN} changeCustodianTs - Timestamp when 'change_custodian' was initiated\n * @property {BN} sendMsgTs - Timestamp when 'send_raw_msg' was initiated\n * @property {BN} codeUpgradeTs - Timestamp when 'code_upgrade' was initiated\n * @property {Address} newCustodian - New custodian that will be set after confirmation\n * @property {Cell} pendingMsg - Pending msg that will be sends after confirmation\n * @property {Cell} newCode - New contract code that will be set after confirmation\n * @property {Cell} newStorage - New contract storage that will be set after confirmation\n */\nexport type PendingData = {\n  changeCustodianTs: BN;\n  sendMsgTs: BN;\n  codeUpgradeTs: BN;\n  newCustodian: Address | null;\n  pendingMsg: Cell;\n  newCode: Cell;\n  newStorage: Cell;\n};\n\n/**\n * @since V2 revision\n * @typedef {Object} Version\n *\n * @property {number} major - Major version; breaking changes in api\n * @property {number} minor - Minor version; non-breaking new functionality\n * @property {string} development - Development version; can contain breaking changes\n */\nexport type Version = {\n  major: number;\n  minor: number;\n  development: string;\n};\n\ninterface FarmNftMinterOptions extends NftCollectionOptions {\n  revision: FarmNftMinterRevision | keyof typeof REVISIONS;\n  address: AddressType;\n}\n\nexport class FarmNftMinter extends NftCollection {\n  private revision: FarmNftMinterRevision;\n\n  constructor(\n    provider: HttpProvider,\n    { revision, ...options }: FarmNftMinterOptions,\n  ) {\n    super(provider, options);\n\n    if (typeof revision === 'string') {\n      if (!REVISIONS[revision])\n        throw Error(`Unknown pool revision: ${revision}`);\n\n      this.revision = new REVISIONS[revision]();\n    } else {\n      this.revision = revision;\n    }\n  }\n\n  public get gasConstants(): FarmNftMinterGasConstants {\n    return this.revision.gasConstants;\n  }\n\n  /**\n   * Create a payload for the `stake` transaction.\n   *\n   * @returns payload for the `stake` transaction.\n   */\n  public async createStakeBody(): Promise<Cell> {\n    return this.revision.createStakeBody(this);\n  }\n\n  /**\n   * @returns {Address} address of minter for staking jetton\n   */\n  public async getStakingJettonAddress(): Promise<Address> {\n    const { stakingTokenWallet } = await this.getData();\n\n    const jettonWallet = new JettonWallet(\n      this.provider,\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      {\n        address: stakingTokenWallet,\n      },\n    );\n\n    const { jettonMinterAddress } = await jettonWallet.getData();\n\n    return jettonMinterAddress;\n  }\n\n  public async getPendingData(): Promise<PendingData> {\n    return this.revision.getPendingData(this);\n  }\n\n  public async getVersion(): Promise<Version> {\n    return this.revision.getVersion(this);\n  }\n\n  /**\n   * @returns {FarmNftMinterData} containing current state of the minter\n   */\n  public async getData(): Promise<FarmNftMinterData> {\n    return this.revision.getData(this);\n  }\n\n  /**\n   * Build all data required to execute a jetton `stake` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.jettonAddress - Jetton address of token to be staked\n   * @param {BN | number} params.jettonAmount - Amount of tokens to be staked (in basic token units)\n   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)\n   * @param {BN | number | undefined} params.forwardGasAmount - Optional; forward amount of gas for the next transaction (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} containing all data required to execute a jetton `stake` transaction\n   */\n  public async buildStakeTxParams(params: {\n    userWalletAddress: AddressType;\n    jettonAddress: AddressType;\n    jettonAmount: AmountType;\n    gasAmount?: AmountType;\n    forwardGasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const jetton = new JettonMinter(\n      this.provider,\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      {\n        address: params.jettonAddress,\n      },\n    );\n\n    const jettonWalletAddress = await jetton.getJettonWalletAddress(\n      new Address(params.userWalletAddress),\n    );\n\n    const forwardPayload = await this.createStakeBody();\n\n    const forwardTonAmount = new BN(\n      params.forwardGasAmount ?? this.gasConstants.stakeForward,\n    );\n\n    const payload = createJettonTransferMessage({\n      queryId: params.queryId ?? 0,\n      amount: params.jettonAmount,\n      destination: await this.getAddress(),\n      responseDestination: params.userWalletAddress,\n      forwardTonAmount,\n      forwardPayload,\n    });\n\n    const gasAmount = new BN(params.gasAmount ?? this.gasConstants.stake);\n\n    return {\n      to: jettonWalletAddress,\n      payload,\n      gasAmount,\n    };\n  }\n}\n","import TonWeb from 'tonweb';\n\nimport type { QueryIdType, Cell } from '@/types';\n\nconst {\n  boc: { Cell },\n} = TonWeb;\n\n/**\n * Implements `destroy` function from SBT Standard.\n * [Docs](https://github.com/ton-blockchain/TEPs/blob/master/text/0085-sbt-standard.md#3-destroy)\n *\n * ```TL-B\n * destroy#1f04537a query_id:uint64 = InternalMsgBody;\n * ```\n */\nexport function createSbtDestroyMessage(params?: { queryId: QueryIdType }) {\n  const message = new Cell();\n\n  message.bits.writeUint(0x1f04537a, 32);\n  message.bits.writeUint(params?.queryId ?? 0, 64);\n\n  return message;\n}\n","import TonWeb from 'tonweb';\n\nimport { FARM_OP_CODES } from '../constants';\nimport type { Cell, BN } from '@/types';\nimport { createSbtDestroyMessage } from '@/utils/createSbtDestroyMessage';\n\nimport type { FarmNftItemRevision } from './FarmNftItemRevision';\n\nconst {\n  utils: { BN },\n  boc: { Cell },\n} = TonWeb;\n\nexport class FarmNftItemRevisionV2 implements FarmNftItemRevision {\n  public get gasConstants(): FarmNftItemRevision['gasConstants'] {\n    return {\n      claimRewards: new BN(300000000),\n      unstake: new BN(400000000),\n      destroy: new BN(50000000),\n    };\n  }\n\n  public createClaimRewardsBody: FarmNftItemRevision['createClaimRewardsBody'] =\n    async (_nft, params) => {\n      const message = new Cell();\n\n      message.bits.writeUint(FARM_OP_CODES.CLAIM_REWARDS, 32);\n      message.bits.writeUint(params?.queryId ?? 0, 64);\n\n      return message;\n    };\n\n  public createUnstakeBody: FarmNftItemRevision['createUnstakeBody'] = async (\n    _nft,\n    params,\n  ) => {\n    const message = new Cell();\n\n    message.bits.writeUint(FARM_OP_CODES.UNSTAKE, 32);\n    message.bits.writeUint(params?.queryId ?? 0, 64);\n\n    return message;\n  };\n\n  public createDestroyBody: FarmNftItemRevision['createDestroyBody'] = async (\n    _nft,\n    params,\n  ) => {\n    return createSbtDestroyMessage({\n      queryId: params?.queryId ?? 0,\n    });\n  };\n\n  public getFarmingData: FarmNftItemRevision['getFarmingData'] = async (\n    nft,\n  ) => {\n    const contractAddress = await nft.getAddress();\n\n    const result = await nft.provider.call2(\n      contractAddress.toString(),\n      'get_farming_data',\n    );\n\n    return {\n      status: result[0] as number,\n      revokeTime: result[1] as BN,\n      stakedTokens: result[2] as BN,\n      claimedPerUnitNanorewards: result[3] as BN,\n      stakeDate: result[4] as BN,\n\n      // NFTs are always soulbound in V2\n      isSoulbound: true,\n    };\n  };\n}\n","import TonWeb from 'tonweb';\n\nimport type {\n  Cell,\n  HttpProvider,\n  BN,\n  AddressType,\n  QueryIdType,\n  MessageData,\n  AmountType,\n  NftItemOptions,\n} from '@/types';\nimport { FARM_REVISION } from '../constants';\n\nimport { FarmNftItemRevision } from './FarmNftItemRevision';\nimport { FarmNftItemRevisionV2 } from './FarmNftItemRevisionV2';\n\nconst {\n  utils: { BN },\n  token: {\n    nft: { NftItem },\n  },\n} = TonWeb;\n\nconst REVISIONS = {\n  [FARM_REVISION.V2]: FarmNftItemRevisionV2,\n} as const;\n\nexport type FarmNftItemGasConstants = {\n  claimRewards: BN;\n  unstake: BN;\n  destroy: BN;\n};\n\n/**\n * @type {FarmNftItemFarmingData} represent state of the farm NFT\n *\n * @property {number} status Status of the contract: uninitialized `0`, active `1`, unstaked `2`, claiming `3`\n * @property {boolean} isSoulbound If nft is soulbound\n * @property {BN} revokeTime Timestamp of unstake @since V2 revision\n * @property {BN} stakedTokens Amount of staked tokens\n * @property {BN} claimedPerUnitNanorewards `accrued_per_unit_nanorewards` at the time the user made the stake or last claimed rewards\n * @property {BN} stakeDate Timestamp in which the owner started staking\n */\nexport type FarmNftItemFarmingData = {\n  status: number;\n  isSoulbound: boolean;\n  revokeTime: BN;\n  stakedTokens: BN;\n  claimedPerUnitNanorewards: BN;\n  stakeDate: BN;\n};\n\ninterface FarmNftItemOptions extends NftItemOptions {\n  revision: FarmNftItemRevision | keyof typeof REVISIONS;\n  address: AddressType;\n}\n\nexport class FarmNftItem extends NftItem {\n  private revision: FarmNftItemRevision;\n\n  constructor(\n    provider: HttpProvider,\n    { revision, ...options }: FarmNftItemOptions,\n  ) {\n    super(provider, options);\n\n    if (typeof revision === 'string') {\n      if (!REVISIONS[revision])\n        throw Error(`Unknown farm NFT item revision: ${revision}`);\n\n      this.revision = new REVISIONS[revision]();\n    } else {\n      this.revision = revision;\n    }\n  }\n\n  public get gasConstants(): FarmNftItemGasConstants {\n    return this.revision.gasConstants;\n  }\n\n  /**\n   * Creates payload for the `claim_rewards` transaction.\n   *\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {Cell} payload for the `claim_rewards` transaction.\n   */\n  public async createClaimRewardsBody(params: {\n    queryId?: QueryIdType;\n  }): Promise<Cell> {\n    return this.revision.createClaimRewardsBody(this, params);\n  }\n\n  /**\n   * Creates payload for the `destroy` transaction.\n   *\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {Cell} payload for the `destroy` transaction.\n   */\n  public async createDestroyBody(params: {\n    queryId?: QueryIdType;\n  }): Promise<Cell> {\n    return this.revision.createDestroyBody(this, params);\n  }\n\n  /**\n   * Creates payload for the `unstake` transaction.\n   *\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {Cell} payload for the `unstake` transaction.\n   */\n  public async createUnstakeBody(params: {\n    queryId?: QueryIdType;\n  }): Promise<Cell> {\n    return this.revision.createUnstakeBody(this, params);\n  }\n\n  /**\n   * @returns {FarmNftItemFarmingData} structure containing current state of the farm NFT\n   */\n  public async getFarmingData(): Promise<FarmNftItemFarmingData> {\n    return await this.revision.getFarmingData(this);\n  }\n\n  /**\n   * Build all data required to execute a `claim_rewards` transaction.\n   *\n   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} all data required to execute a `claim_rewards` transaction.\n   */\n  public async buildClaimRewardsTxParams(params?: {\n    gasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const to = await this.getAddress();\n\n    const payload = await this.createClaimRewardsBody({\n      queryId: params?.queryId,\n    });\n\n    const gasAmount = new BN(\n      params?.gasAmount ?? this.gasConstants.claimRewards,\n    );\n\n    return { to, payload, gasAmount };\n  }\n\n  /**\n   * Build all data required to execute a `unstake` transaction.\n   *\n   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} all data required to execute a `unstake` transaction.\n   */\n  public async buildUnstakeTxParams(params?: {\n    gasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const to = await this.getAddress();\n\n    const payload = await this.createUnstakeBody({ queryId: params?.queryId });\n\n    const gasAmount = new BN(params?.gasAmount ?? this.gasConstants.unstake);\n\n    return { to, payload, gasAmount };\n  }\n\n  /**\n   * Build all data required to execute a `destroy` transaction.\n   *\n   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} all data required to execute a `destroy` transaction.\n   */\n  public async buildDestroyTxParams(params?: {\n    gasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const to = await this.getAddress();\n\n    const payload = await this.createDestroyBody({ queryId: params?.queryId });\n\n    const gasAmount = new BN(params?.gasAmount ?? this.gasConstants.destroy);\n\n    return {\n      to,\n      payload,\n      gasAmount,\n    };\n  }\n}\n","export { createJettonTransferMessage } from './createJettonTransferMessage';\nexport { createSbtDestroyMessage } from './createSbtDestroyMessage';\nexport { parseAddress } from './parseAddress';\nexport { parseBoolean } from './parseBoolean';\nexport { parseString } from './parseString';\n\nimport { parseAddress } from './parseAddress';\n\n/** @deprecated Use `parseAddress` instead. */\nexport const parseAddressFromCell = parseAddress;\n"],"names":["DEX_OP_CODES","ROUTER_REVISION","ROUTER_REVISION_ADDRESS","Address","TonWeb","readIntFromBitString","bs","cursor","bits","n","i","parseAddress","cell","hashPart","s","Cell","BN","LpAccountRevisionV1","__publicField","_lpAccount","params","message","lpAccount","contractAddress","result","Contract","REVISIONS","LpAccount","provider","revision","options","to","payload","gasAmount","bytesToBase64","PoolRevisionV1","_pool","pool","slice","poolAddress","JettonMinter","JettonWallet","Pool","poolWalletAddress","accountAddress","createJettonTransferMessage","parseBoolean","bn","RouterRevisionV1","_router","router","cellA","cellB","sliceA","sliceB","routerAddress","Router","jetton0","jetton1","jetton0WalletAddress","jetton1WalletAddress","offerJetton","askJetton","offerJettonWalletAddress","askJettonWalletAddress","forwardPayload","forwardTonAmount","proxyTonMinter","askJettonMinter","proxyTonWalletAddress","sendJettonMinter","otherJettonMinter","jettonWalletAddress","routerWalletAddress","tonProxyMinter","FARM_OP_CODES","FARM_REVISION","parseString","FarmNftMinterRevisionV2","_minter","minter","stakingTokenWallet","rewardTokenWallet","NftCollection","FarmNftMinter","jettonWallet","jettonMinterAddress","createSbtDestroyMessage","FarmNftItemRevisionV2","_nft","nft","NftItem","FarmNftItem","parseAddressFromCell"],"mappings":"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"}